{"ast":null,"code":"/**\r\n * A jsTPS_Transaction represents a single atomic transaction to be managed\r\n * by the jsTPS class in a transaction stack. Each transaction can be done\r\n * and the undone, which should restore the state of the application employing\r\n * this framework.\r\n * \r\n * @author TheMcKillaGorilla\r\n * @version 2.0.4\r\n */\nexport class jsTPS_Transaction {\n  /**\r\n   * This method is called by jsTPS when a transaction is executed.\r\n   */\n  executeDo() {\n    console.log(\"executeDo - MISSING IMPLEMENTATION\");\n  }\n\n  /**\r\n   * This method is called by jsTPS when a transaction is undone.\r\n   */\n  executeUndo() {\n    console.log(\"executeUndo - MISSING IMPLEMENTATION\");\n  }\n}\n\n/**\r\n * Thrown when one tries to undo, or redo a transaction when\r\n * none is available for such an operation.\r\n */\nexport const TRANSACTION_STACK_EXCEPTION = \"TRANSACTION_STACK_EXCEPTION\";\n\n/**\r\n * jsTPS serves as a transaction processing system employing a transaction\r\n * stack such that one can use this framework to implement undo/redo in\r\n * an application.\r\n * \r\n * @author TheMcKillaGorilla\r\n * @version 2.0\r\n */\nexport class jsTPS {\n  /**\r\n   * A Transaction Processing System to be used for implementing\r\n   * undo/redo in a JavaScript application. Note that the transaction\r\n   * stack will start out empty, with no transactions to do or undo.\r\n   * @constructor\r\n   */\n  constructor() {\n    // THE TRANSACTION STACK, MEANING TRANSACTIONS THAT HAVE BEEN\n    // EXECUTED THAT WE CAN UNDO AND THEN REDO\n    this.transactions = [];\n\n    // THE TOTAL NUMBER OF VALID TRANSACTIONS IN THE STACK, INCLUDING THOSE \n    // THAT WE MIGHT REDO, BUT NOT INCLUDING TRANSACTIONS THAT ARE LOST WHEN \n    // BRANCHING OCCURS, MEANING WHEN WE HAVE UNDONE TRANSACTIONS AND THEN\n    // ADD A NEW ONE, WHICH ELIMINATES THOSE ABOVE IT IN THE STACK. NOTE THAT\n    // THIS NUMBER ONLY CHANGES WHEN WE ADD A TRANSACTION.\n    this.size = 0;\n\n    // THE INDEX WHERE A NEW TRANSACTION WOULD BE ADDED ONTO THE STACK\n    // SHOULD processTransaction BE CALLED, WHICH ADDES AND EXECUTES A\n    // TRANSACTION. NOTE THAT FOLLOWING COMBINATIONS OF UNDO AND REDO \n    // THIS INDEX WILL BE ONE MORE THAN THE INDEX OF THE MOST RECENTLY\n    // DONE TRANSACTION.\n    this.topIndex = 0;\n  }\n\n  /**\r\n   * Completely resets the transaction stack, assigning it a new, empty array and\r\n   * resetting the top index and size to reflect an empty stack.\r\n   */\n  clearAllTransactions() {\n    // REMOVE ALL THE TRANSACTIONS\n    this.transactions = [];\n\n    // RESET THE OTHER VARIABLES TOO\n    this.topIndex = 0;\n    this.size = 0;\n  }\n\n  /**\r\n   * Executes the transaction in the stack where our index is and advances the index such\r\n   * that it could then be undone if necessary. Note, this does not change what\r\n   * transactions are on the stack, just the index counter that keeps track of\r\n   * what has been done and undone.\r\n   * \r\n   * @throws {TRANSACTION_STACK_EXCEPTION} thrown if there is no transaction on the\r\n   * stack to do.\r\n   */\n  doTransaction() {\n    if (this.hasTransactionToDo()) {\n      let transaction = this.transactions[this.topIndex];\n      transaction.executeDo();\n      this.topIndex++;\n    } else {\n      throw TRANSACTION_STACK_EXCEPTION;\n    }\n  }\n\n  /**\r\n   * Accessor method for the number of transactions that can currently be done.\r\n   * \r\n   * @returns {Number} The number of transactions in the stack that can be done.\r\n   */\n  getDoSize() {\n    return this.getSize() - this.getUndoSize();\n  }\n\n  /**\r\n   * Accessor method for the total number of transactions in the current stack which\r\n   * includes those that can be done and undone.\r\n   * \r\n   * @returns {Number} The number of transactions in total in the stack.\r\n   */\n  getSize() {\n    return this.size;\n  }\n\n  /**\r\n   * Accessor method for the number of transactions that can currently be undone.\r\n   * \r\n   * @returns {Number} The number of transactions in the stack that can be undone.\r\n   */\n  getUndoSize() {\n    return this.topIndex;\n  }\n\n  /**\r\n   * Used to check if there is an doable transaction in the stack or not, like\r\n   * to redo a transaction, which might be useful for an application for enabling\r\n   * a redo button.\r\n   * \r\n   * @returns true if there is a transaction in the stack that can be done,\r\n   * false othewise.\r\n   */\n  hasTransactionToDo() {\n    return this.getDoSize() > 0;\n  }\n\n  /**\r\n   * Used to check if there is an undoable transaction in the stack or not, like\r\n   * to undo a transaction, which might be useful for an application for enabling\r\n   * an undo button.\r\n   * \r\n   * @returns true if there is a transaction in the stack that can be undone,\r\n   * false otherwise.\r\n   */\n  hasTransactionToUndo() {\n    return this.getUndoSize() > 0;\n  }\n\n  /**\r\n   * Gets a transaction in the stack at a provided index without executing the transaction\r\n   * or changing the stack.\r\n   * \r\n   * @param {Number} index = The index of the transaction in the stack to get, which can\r\n   * be used to get any transaction, even those that have been undone if they are still\r\n   * in the stack.\r\n   * \r\n   * @returns {jsTPS_Transaction} The transaction to retrieve at index in the stack, if\r\n   * an invalid index is provided, null is returned.\r\n   */\n  peekTransaction(index) {\n    if (index >= 0 && index < this.getSize()) {\n      return this.transactions[index];\n    }\n    return null;\n  }\n\n  /**\r\n   * This function takes the transaction argument and both pushes it to the top of the\r\n   * transaction stack and executes it. After this method executes one can undo it, but\r\n   * there should be no transaction to redo as this one will have been executed.\r\n   * @param {jsTPS_Transaction} transaction - The transaction to add to the stack and execute.\r\n   */\n  processTransaction(transaction) {\n    // FIRST ADD THE TRANSACTION TO THE STACK\n    this.transactions[this.topIndex] = transaction;\n\n    // NOW WE NEED TO UPDATE THE SIZE OF THE STACK, WHICH AFTER A TRANSACTION\n    // IS PUSHED ONTO THE TOP, WILL ALWAYS BE TWO MORE THAN topIndex, SINCE\n    // THE TRANSACTION HAS NOT YET BEEN EXECUTED.\n    this.size = this.topIndex + 1;\n\n    // AND THEN EXECUTE IT, WHICH WILL ALSO MOVE THE TOP INDEX\n    this.doTransaction();\n  }\n\n  /**\r\n   * Builds and returns a textual representation of the transaction processing\r\n   * system, which summarizes the contents of the transaction stack.\r\n   * \r\n   * @returns {String} A textual representation of the transaction stack.\r\n   */\n  toString() {\n    let text = \"--Number of Transactions: \" + this.size + \"\\n\";\n    text += \"--Top Index: \" + this.topIndex + \"\\n\";\n    text += \"--Current Transaction Stack:\\n\";\n    for (let i = 0; i <= this.topIndex; i++) {\n      let jT = this.transactions[i];\n      text += \"----\" + jT.toString() + \"\\n\";\n    }\n    return text;\n  }\n\n  /**\r\n   * Undoes the transaction at the top of the stack and decrements the index such\r\n   * that it could then be redone if necessary. Note, this does not change what\r\n   * transactions are on the stack, just the index counter that keeps track of\r\n   * the top of the stack, and thus which transactions would be executed for do\r\n   * and undo operations.\r\n   * \r\n   * @throws {TRANSACTION_STACK_EXCEPTION} thrown if there is no transaction on the\r\n   * stack to undo.\r\n   */\n  undoTransaction() {\n    if (this.hasTransactionToUndo()) {\n      let transaction = this.transactions[this.topIndex - 1];\n      transaction.executeUndo();\n      this.topIndex--;\n    } else {\n      throw TRANSACTION_STACK_EXCEPTION;\n    }\n  }\n}","map":{"version":3,"names":["jsTPS_Transaction","executeDo","console","log","executeUndo","TRANSACTION_STACK_EXCEPTION","jsTPS","constructor","transactions","size","topIndex","clearAllTransactions","doTransaction","hasTransactionToDo","transaction","getDoSize","getSize","getUndoSize","hasTransactionToUndo","peekTransaction","index","processTransaction","toString","text","i","jT","undoTransaction"],"sources":["/Users/anya_biswas/Documents/316-FinalProject/client/node_modules/jstps/index.js"],"sourcesContent":["/**\r\n * A jsTPS_Transaction represents a single atomic transaction to be managed\r\n * by the jsTPS class in a transaction stack. Each transaction can be done\r\n * and the undone, which should restore the state of the application employing\r\n * this framework.\r\n * \r\n * @author TheMcKillaGorilla\r\n * @version 2.0.4\r\n */\r\nexport class jsTPS_Transaction {\r\n    /**\r\n     * This method is called by jsTPS when a transaction is executed.\r\n     */\r\n    executeDo() {\r\n        console.log(\"executeDo - MISSING IMPLEMENTATION\");\r\n    }\r\n\r\n    /**\r\n     * This method is called by jsTPS when a transaction is undone.\r\n     */\r\n    executeUndo() {\r\n        console.log(\"executeUndo - MISSING IMPLEMENTATION\");\r\n    }\r\n}\r\n\r\n/**\r\n * Thrown when one tries to undo, or redo a transaction when\r\n * none is available for such an operation.\r\n */\r\nexport const TRANSACTION_STACK_EXCEPTION = \"TRANSACTION_STACK_EXCEPTION\";\r\n\r\n/**\r\n * jsTPS serves as a transaction processing system employing a transaction\r\n * stack such that one can use this framework to implement undo/redo in\r\n * an application.\r\n * \r\n * @author TheMcKillaGorilla\r\n * @version 2.0\r\n */\r\nexport class jsTPS {\r\n    /**\r\n     * A Transaction Processing System to be used for implementing\r\n     * undo/redo in a JavaScript application. Note that the transaction\r\n     * stack will start out empty, with no transactions to do or undo.\r\n     * @constructor\r\n     */\r\n    constructor() {\r\n        // THE TRANSACTION STACK, MEANING TRANSACTIONS THAT HAVE BEEN\r\n        // EXECUTED THAT WE CAN UNDO AND THEN REDO\r\n        this.transactions = [];\r\n\r\n        // THE TOTAL NUMBER OF VALID TRANSACTIONS IN THE STACK, INCLUDING THOSE \r\n        // THAT WE MIGHT REDO, BUT NOT INCLUDING TRANSACTIONS THAT ARE LOST WHEN \r\n        // BRANCHING OCCURS, MEANING WHEN WE HAVE UNDONE TRANSACTIONS AND THEN\r\n        // ADD A NEW ONE, WHICH ELIMINATES THOSE ABOVE IT IN THE STACK. NOTE THAT\r\n        // THIS NUMBER ONLY CHANGES WHEN WE ADD A TRANSACTION.\r\n        this.size = 0;\r\n\r\n        // THE INDEX WHERE A NEW TRANSACTION WOULD BE ADDED ONTO THE STACK\r\n        // SHOULD processTransaction BE CALLED, WHICH ADDES AND EXECUTES A\r\n        // TRANSACTION. NOTE THAT FOLLOWING COMBINATIONS OF UNDO AND REDO \r\n        // THIS INDEX WILL BE ONE MORE THAN THE INDEX OF THE MOST RECENTLY\r\n        // DONE TRANSACTION.\r\n        this.topIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Completely resets the transaction stack, assigning it a new, empty array and\r\n     * resetting the top index and size to reflect an empty stack.\r\n     */\r\n    clearAllTransactions() {\r\n        // REMOVE ALL THE TRANSACTIONS\r\n        this.transactions = [];\r\n\r\n        // RESET THE OTHER VARIABLES TOO\r\n        this.topIndex = 0;\r\n        this.size = 0;\r\n    }\r\n\r\n    /**\r\n     * Executes the transaction in the stack where our index is and advances the index such\r\n     * that it could then be undone if necessary. Note, this does not change what\r\n     * transactions are on the stack, just the index counter that keeps track of\r\n     * what has been done and undone.\r\n     * \r\n     * @throws {TRANSACTION_STACK_EXCEPTION} thrown if there is no transaction on the\r\n     * stack to do.\r\n     */\r\n    doTransaction() {\r\n        if (this.hasTransactionToDo()) {\r\n            let transaction = this.transactions[this.topIndex];\r\n            transaction.executeDo();\r\n            this.topIndex++;\r\n        }\r\n        else {\r\n            throw TRANSACTION_STACK_EXCEPTION;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Accessor method for the number of transactions that can currently be done.\r\n     * \r\n     * @returns {Number} The number of transactions in the stack that can be done.\r\n     */\r\n    getDoSize() {\r\n        return this.getSize() - this.getUndoSize();\r\n    }\r\n\r\n    /**\r\n     * Accessor method for the total number of transactions in the current stack which\r\n     * includes those that can be done and undone.\r\n     * \r\n     * @returns {Number} The number of transactions in total in the stack.\r\n     */\r\n    getSize() {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Accessor method for the number of transactions that can currently be undone.\r\n     * \r\n     * @returns {Number} The number of transactions in the stack that can be undone.\r\n     */\r\n    getUndoSize() {\r\n        return this.topIndex;\r\n    }\r\n\r\n    /**\r\n     * Used to check if there is an doable transaction in the stack or not, like\r\n     * to redo a transaction, which might be useful for an application for enabling\r\n     * a redo button.\r\n     * \r\n     * @returns true if there is a transaction in the stack that can be done,\r\n     * false othewise.\r\n     */\r\n    hasTransactionToDo() {\r\n        return (this.getDoSize() > 0);\r\n    }\r\n\r\n    /**\r\n     * Used to check if there is an undoable transaction in the stack or not, like\r\n     * to undo a transaction, which might be useful for an application for enabling\r\n     * an undo button.\r\n     * \r\n     * @returns true if there is a transaction in the stack that can be undone,\r\n     * false otherwise.\r\n     */\r\n    hasTransactionToUndo() {\r\n        return (this.getUndoSize() > 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a transaction in the stack at a provided index without executing the transaction\r\n     * or changing the stack.\r\n     * \r\n     * @param {Number} index = The index of the transaction in the stack to get, which can\r\n     * be used to get any transaction, even those that have been undone if they are still\r\n     * in the stack.\r\n     * \r\n     * @returns {jsTPS_Transaction} The transaction to retrieve at index in the stack, if\r\n     * an invalid index is provided, null is returned.\r\n     */\r\n    peekTransaction(index) {\r\n        if ((index >= 0) && (index < this.getSize())) {\r\n            return this.transactions[index];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This function takes the transaction argument and both pushes it to the top of the\r\n     * transaction stack and executes it. After this method executes one can undo it, but\r\n     * there should be no transaction to redo as this one will have been executed.\r\n     * @param {jsTPS_Transaction} transaction - The transaction to add to the stack and execute.\r\n     */\r\n    processTransaction(transaction) {\r\n        // FIRST ADD THE TRANSACTION TO THE STACK\r\n        this.transactions[this.topIndex] = transaction;\r\n\r\n        // NOW WE NEED TO UPDATE THE SIZE OF THE STACK, WHICH AFTER A TRANSACTION\r\n        // IS PUSHED ONTO THE TOP, WILL ALWAYS BE TWO MORE THAN topIndex, SINCE\r\n        // THE TRANSACTION HAS NOT YET BEEN EXECUTED.\r\n        this.size = this.topIndex + 1;\r\n\r\n        // AND THEN EXECUTE IT, WHICH WILL ALSO MOVE THE TOP INDEX\r\n        this.doTransaction();\r\n    }\r\n\r\n    /**\r\n     * Builds and returns a textual representation of the transaction processing\r\n     * system, which summarizes the contents of the transaction stack.\r\n     * \r\n     * @returns {String} A textual representation of the transaction stack.\r\n     */\r\n    toString() {\r\n        let text = \"--Number of Transactions: \" + this.size + \"\\n\";\r\n        text += \"--Top Index: \" + this.topIndex + \"\\n\";\r\n        text += \"--Current Transaction Stack:\\n\";\r\n        for (let i = 0; i <= this.topIndex; i++) {\r\n            let jT = this.transactions[i];\r\n            text += \"----\" + jT.toString() + \"\\n\";\r\n        }\r\n        return text;\r\n    }\r\n\r\n    /**\r\n     * Undoes the transaction at the top of the stack and decrements the index such\r\n     * that it could then be redone if necessary. Note, this does not change what\r\n     * transactions are on the stack, just the index counter that keeps track of\r\n     * the top of the stack, and thus which transactions would be executed for do\r\n     * and undo operations.\r\n     * \r\n     * @throws {TRANSACTION_STACK_EXCEPTION} thrown if there is no transaction on the\r\n     * stack to undo.\r\n     */\r\n    undoTransaction() {\r\n        if (this.hasTransactionToUndo()) {\r\n            let transaction = this.transactions[this.topIndex - 1];\r\n            transaction.executeUndo();\r\n            this.topIndex--;\r\n        }\r\n        else {\r\n            throw TRANSACTION_STACK_EXCEPTION;\r\n        }\r\n    }\r\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,iBAAiB,CAAC;EAC3B;AACJ;AACA;EACIC,SAASA,CAAA,EAAG;IACRC,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;EACrD;;EAEA;AACJ;AACA;EACIC,WAAWA,CAAA,EAAG;IACVF,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;EACvD;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAME,2BAA2B,GAAG,6BAA6B;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,KAAK,CAAC;EACf;AACJ;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAAA,EAAG;IACV;IACA;IACA,IAAI,CAACC,YAAY,GAAG,EAAE;;IAEtB;IACA;IACA;IACA;IACA;IACA,IAAI,CAACC,IAAI,GAAG,CAAC;;IAEb;IACA;IACA;IACA;IACA;IACA,IAAI,CAACC,QAAQ,GAAG,CAAC;EACrB;;EAEA;AACJ;AACA;AACA;EACIC,oBAAoBA,CAAA,EAAG;IACnB;IACA,IAAI,CAACH,YAAY,GAAG,EAAE;;IAEtB;IACA,IAAI,CAACE,QAAQ,GAAG,CAAC;IACjB,IAAI,CAACD,IAAI,GAAG,CAAC;EACjB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,aAAaA,CAAA,EAAG;IACZ,IAAI,IAAI,CAACC,kBAAkB,CAAC,CAAC,EAAE;MAC3B,IAAIC,WAAW,GAAG,IAAI,CAACN,YAAY,CAAC,IAAI,CAACE,QAAQ,CAAC;MAClDI,WAAW,CAACb,SAAS,CAAC,CAAC;MACvB,IAAI,CAACS,QAAQ,EAAE;IACnB,CAAC,MACI;MACD,MAAML,2BAA2B;IACrC;EACJ;;EAEA;AACJ;AACA;AACA;AACA;EACIU,SAASA,CAAA,EAAG;IACR,OAAO,IAAI,CAACC,OAAO,CAAC,CAAC,GAAG,IAAI,CAACC,WAAW,CAAC,CAAC;EAC9C;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACID,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACP,IAAI;EACpB;;EAEA;AACJ;AACA;AACA;AACA;EACIQ,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAACP,QAAQ;EACxB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,kBAAkBA,CAAA,EAAG;IACjB,OAAQ,IAAI,CAACE,SAAS,CAAC,CAAC,GAAG,CAAC;EAChC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,oBAAoBA,CAAA,EAAG;IACnB,OAAQ,IAAI,CAACD,WAAW,CAAC,CAAC,GAAG,CAAC;EAClC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,eAAeA,CAACC,KAAK,EAAE;IACnB,IAAKA,KAAK,IAAI,CAAC,IAAMA,KAAK,GAAG,IAAI,CAACJ,OAAO,CAAC,CAAE,EAAE;MAC1C,OAAO,IAAI,CAACR,YAAY,CAACY,KAAK,CAAC;IACnC;IACA,OAAO,IAAI;EACf;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIC,kBAAkBA,CAACP,WAAW,EAAE;IAC5B;IACA,IAAI,CAACN,YAAY,CAAC,IAAI,CAACE,QAAQ,CAAC,GAAGI,WAAW;;IAE9C;IACA;IACA;IACA,IAAI,CAACL,IAAI,GAAG,IAAI,CAACC,QAAQ,GAAG,CAAC;;IAE7B;IACA,IAAI,CAACE,aAAa,CAAC,CAAC;EACxB;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIU,QAAQA,CAAA,EAAG;IACP,IAAIC,IAAI,GAAG,4BAA4B,GAAG,IAAI,CAACd,IAAI,GAAG,IAAI;IAC1Dc,IAAI,IAAI,eAAe,GAAG,IAAI,CAACb,QAAQ,GAAG,IAAI;IAC9Ca,IAAI,IAAI,gCAAgC;IACxC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,IAAI,CAACd,QAAQ,EAAEc,CAAC,EAAE,EAAE;MACrC,IAAIC,EAAE,GAAG,IAAI,CAACjB,YAAY,CAACgB,CAAC,CAAC;MAC7BD,IAAI,IAAI,MAAM,GAAGE,EAAE,CAACH,QAAQ,CAAC,CAAC,GAAG,IAAI;IACzC;IACA,OAAOC,IAAI;EACf;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,eAAeA,CAAA,EAAG;IACd,IAAI,IAAI,CAACR,oBAAoB,CAAC,CAAC,EAAE;MAC7B,IAAIJ,WAAW,GAAG,IAAI,CAACN,YAAY,CAAC,IAAI,CAACE,QAAQ,GAAG,CAAC,CAAC;MACtDI,WAAW,CAACV,WAAW,CAAC,CAAC;MACzB,IAAI,CAACM,QAAQ,EAAE;IACnB,CAAC,MACI;MACD,MAAML,2BAA2B;IACrC;EACJ;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}